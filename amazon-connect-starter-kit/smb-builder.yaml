AWSTemplateFormatVersion: '2010-09-09'
Description: 'Amazon Connect with Customer Profiles and Static Website using CloudFront-hosted source files'

Parameters:
  # Website parameters
  S3BucketName:
    Type: String
    Description: Globally unique S3 bucket name for the website (3-63 chars, lowercase)
    
  # FAQ Bucket parameters
  FAQBucketName:
    Type: String
    Description: Globally unique S3 bucket name for storing FAQ documents (3-63 chars, lowercase)
  
  # Connect parameters
  InstanceAlias:
    Type: String
    Description: Globally unique alias for the Amazon Connect instance.
      
  AdminUsername:
    Type: String
    Description: Username for the Connect admin user
    Default: admin
    
  AdminPassword:
    Type: String
    Description: Password for the Connect admin user
    NoEcho: true
    MinLength: 8
    MaxLength: 64
    Default: Admin123!
Resources:
  #===== SECTION 1: SOURCE FILES SETUP =====
  
  # Temporary S3 bucket for storing extracted files
  SourceFilesBucket:
    Type: AWS::S3::Bucket
    Properties:
      # Auto-delete after 1 day to clean up
      LifecycleConfiguration:
        Rules:
          - Id: DeleteAfterOneDay
            Status: Enabled
            ExpirationInDays: 1
      # Block all public access
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
        
  # S3 Bucket for FAQ documents
  FAQBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref FAQBucketName
      # Block all public access by default
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
        
  # IAM Role for the file downloader Lambda
  DownloadFilesRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3WriteAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}'
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}/*'
                  - !Sub 'arn:aws:s3:::${FAQBucket}'
                  - !Sub 'arn:aws:s3:::${FAQBucket}/*'
                  
  # Lambda function to download and extract files
  DownloadFilesFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Runtime: python3.9
      Timeout: 300
      MemorySize: 512
      Role: !GetAtt DownloadFilesRole.Arn
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import urllib.request
          import zipfile
          import io
          import os
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              try:
                  source_url = event['ResourceProperties']['SourceURL']
                  bucket_name = event['ResourceProperties']['BucketName']
                  faq_bucket_name = event['ResourceProperties'].get('FAQBucketName')
                  
                  # If this is a Delete request, just send success and return
                  if event['RequestType'] == 'Delete':
                      logger.info("Delete request - sending success response")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  # Download the zip file
                  logger.info(f"Downloading files from {source_url}")
                  response = urllib.request.urlopen(source_url)
                  zip_content = response.read()
                  
                  # Extract and upload files
                  s3 = boto3.client('s3')
                  uploaded_files = []
                  faq_files = []
                  
                  with zipfile.ZipFile(io.BytesIO(zip_content)) as zip_ref:
                      # Log all files in the zip for debugging
                      all_files = zip_ref.namelist()
                      logger.info(f"Files in zip: {all_files}")
                      
                      for file_info in zip_ref.infolist():
                          if file_info.is_dir():
                              continue
                              
                          # Extract the file
                          with zip_ref.open(file_info) as file:
                              content = file.read()
                          
                          # Use the full path as the key
                          file_path = file_info.filename
                          
                          # Skip if it's just the root directory
                          if not file_path or file_path.endswith('/'):
                              continue
                          
                          # Check if this is the FAQ_Bank.docx file
                          if file_path.endswith('FAQ_Bank.docx') or file_path.endswith('FAQ/FAQ_Bank.docx'):
                              if faq_bucket_name:
                                  # Upload to FAQ bucket root
                                  logger.info(f"Uploading FAQ_Bank.docx to {faq_bucket_name}")
                                  s3.put_object(
                                      Bucket=faq_bucket_name,
                                      Key='FAQ_Bank.docx',
                                      Body=content,
                                      ContentType='application/vnd.openxmlformats-officedocument.wordprocessingml.document'
                                  )
                                  faq_files.append('FAQ_Bank.docx')
                              
                          # Determine content type
                          content_type = 'application/octet-stream'
                          if file_path.endswith('.json'):
                              content_type = 'application/json'
                          elif file_path.endswith('.html'):
                              content_type = 'text/html'
                          elif file_path.endswith('.png'):
                              content_type = 'image/png'
                              
                          # Upload to S3
                          logger.info(f"Uploading {file_path} to {bucket_name}")
                          s3.put_object(
                              Bucket=bucket_name,
                              Key=file_path,
                              Body=content,
                              ContentType=content_type
                          )
                          uploaded_files.append(file_path)
                  
                  logger.info(f"Successfully uploaded {len(uploaded_files)} files")
                  logger.info(f"Successfully uploaded {len(faq_files)} FAQ files to FAQ bucket")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'Message': f'Files downloaded and extracted successfully: {len(uploaded_files)} files',
                      'UploadedFiles': uploaded_files,
                      'FAQFiles': faq_files
                  })
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })
                  
  # Custom resource to trigger file download
  DownloadFilesCustomResource:
    Type: Custom::DownloadFiles
    Properties:
      ServiceToken: !GetAtt DownloadFilesFunction.Arn
      SourceURL: "https://d39zldg8jgybym.cloudfront.net/deployment.zip"
      BucketName: !Ref SourceFilesBucket
      FAQBucketName: !Ref FAQBucket
  #===== SECTION 2: WEBSITE RESOURCES =====
  
  # S3 Bucket for Website
  S3Bucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Ref S3BucketName
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true

  # Bucket Policy for CloudFront Access
  BucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref S3Bucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudFrontAccess
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub arn:aws:s3:::${S3BucketName}/*
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}

  # CloudFront Origin Access Control
  CloudFrontOriginAccessControl:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub "${AWS::StackName}-OAC"
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # CloudFront Distribution
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt S3Bucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ""
            OriginAccessControlId: !Ref CloudFrontOriginAccessControl
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachedMethods:
            - GET
            - HEAD
            - OPTIONS
          CachePolicyId: !Ref DefaultCachePolicy
          OriginRequestPolicyId: !Ref OriginRequestPolicy
        ViewerCertificate:
          CloudFrontDefaultCertificate: true

  # Cache Policy for CloudFront
  DefaultCachePolicy:
    Type: AWS::CloudFront::CachePolicy
    Properties:
      CachePolicyConfig:
        Name: !Sub "${AWS::StackName}-CachePolicy"
        DefaultTTL: 86400
        MaxTTL: 31536000
        MinTTL: 0
        ParametersInCacheKeyAndForwardedToOrigin:
          EnableAcceptEncodingGzip: true
          EnableAcceptEncodingBrotli: false
          CookiesConfig:
            CookieBehavior: none
          HeadersConfig:
            HeaderBehavior: none
          QueryStringsConfig:
            QueryStringBehavior: none
            
  # Origin Request Policy for CloudFront
  OriginRequestPolicy:
    Type: AWS::CloudFront::OriginRequestPolicy
    Properties:
      OriginRequestPolicyConfig:
        Name: !Sub "${AWS::StackName}-OriginRequestPolicy"
        CookiesConfig:
          CookieBehavior: none
        HeadersConfig:
          HeaderBehavior: none
        QueryStringsConfig:
          QueryStringBehavior: none
            
  # Role for Copy Files Lambda
  CopyFilesRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: S3CopyAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}'
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}/*'
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::${S3Bucket}'
                  - !Sub 'arn:aws:s3:::${S3Bucket}/*'

  # Lambda Function to Copy Website Files
  CopyFilesFunction:
    Type: AWS::Lambda::Function
    Properties:
      Handler: index.handler
      Role: !GetAtt CopyFilesRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              logger.info('Received event: %s', event)
              
              # Initialize response
              response_data = {}
              
              try:
                  if event['RequestType'] == 'Create' or event['RequestType'] == 'Update':
                      # Get parameters
                      source_bucket = event['ResourceProperties']['SourceBucket']
                      dest_bucket = event['ResourceProperties']['DestBucket']
                      
                      s3_client = boto3.client('s3')
                      
                      # List all objects in the source bucket to find the HTML files
                      logger.info(f'Listing objects in {source_bucket}')
                      response = s3_client.list_objects_v2(
                          Bucket=source_bucket
                      )
                      
                      # Find the index.html and image.png files
                      index_file = None
                      image_file = None
                      
                      if 'Contents' in response:
                          for item in response['Contents']:
                              key = item['Key']
                              if key.endswith('/index.html') or key == 'index.html':
                                  index_file = key
                                  logger.info(f'Found index.html at {index_file}')
                              elif key.endswith('/image.png') or key == 'image.png':
                                  image_file = key
                                  logger.info(f'Found image.png at {image_file}')
                      
                      # If we found the files, copy them
                      if index_file:
                          logger.info(f'Copying {index_file} from {source_bucket} to {dest_bucket}')
                          s3_client.copy_object(
                              CopySource={'Bucket': source_bucket, 'Key': index_file},
                              Bucket=dest_bucket,
                              Key='index.html',  # Place at root of destination bucket
                              ContentType='text/html'
                          )
                      else:
                          logger.error('Could not find index.html in source bucket')
                          raise Exception('Could not find index.html in source bucket')
                      
                      if image_file:
                          logger.info(f'Copying {image_file} from {source_bucket} to {dest_bucket}')
                          s3_client.copy_object(
                              CopySource={'Bucket': source_bucket, 'Key': image_file},
                              Bucket=dest_bucket,
                              Key='image.png',  # Place at root of destination bucket
                              ContentType='image/png'
                          )
                      else:
                          logger.error('Could not find image.png in source bucket')
                          raise Exception('Could not find image.png in source bucket')
                      
                      response_data['Message'] = 'Files copied successfully'
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
              except Exception as e:
                  logger.error('Error: %s', str(e))
                  cfnresponse.send(event, context, cfnresponse.FAILED, {'Error': str(e)})

  # Custom Resource to Trigger File Copy
  CopyFilesCustomResource:
    Type: Custom::CopyFiles
    DependsOn: 
      - S3Bucket
      - DownloadFilesCustomResource
    Properties:
      ServiceToken: !GetAtt CopyFilesFunction.Arn
      SourceBucket: !Ref SourceFilesBucket
      DestBucket: !Ref S3Bucket
  #===== SECTION 3: AMAZON CONNECT INSTANCE AND CUSTOMER PROFILES =====
  
  # Amazon Connect Instance
  ConnectInstance:
    Type: AWS::Connect::Instance
    Properties:
      Attributes:
        InboundCalls: true
        OutboundCalls: true
      IdentityManagementType: CONNECT_MANAGED
      InstanceAlias: !Ref InstanceAlias

  # Customer Profiles Domain
  CustomerProfilesDomain:
    Type: AWS::CustomerProfiles::Domain
    Properties:
      DomainName: !Sub 'amazon-connect-${AWS::StackName}'
      DefaultExpirationDays: 366

  # Customer Profiles Integration with Connect
  CustomerProfilesIntegration:
    Type: AWS::CustomerProfiles::Integration
    DependsOn:
      - ConnectInstance
      - CustomerProfilesDomain
    Properties:
      DomainName: !Sub 'amazon-connect-${AWS::StackName}'
      ObjectTypeName: "CTR"
      Uri: !GetAtt ConnectInstance.Arn
      Tags:
        - Key: "Purpose"
          Value: "Connect-CustomerProfiles-Integration"
          
  # IAM Role for Connect Setup
  ConnectSetupRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: 
                - lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ConnectSetupPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - connect:*
                  - profile:*
                  - iam:PassRole
                  - iam:GetRole
                  - iam:CreateServiceLinkedRole
                Resource: '*'
  # Get Default Routing Profile
  DefaultRoutingProfile:
    Type: Custom::GetDefaultRoutingProfile
    DependsOn: ConnectInstance
    Properties:
      ServiceToken: !GetAtt GetDefaultRoutingProfileFunction.Arn
      InstanceId: !Ref ConnectInstance
      InstanceArn: !GetAtt ConnectInstance.Arn

  # Lambda function to get default routing profile
  GetDefaultRoutingProfileFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - ConnectInstance
      - ConnectSetupRole
    Properties:
      Handler: index.handler
      Role: !GetAtt ConnectSetupRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              logger.info(f"Event: {event}")
              
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      instance_id = event['ResourceProperties']['InstanceId']
                      instance_arn = event['ResourceProperties']['InstanceArn']
                      
                      # Get the default routing profile
                      connect = boto3.client('connect')
                      response = connect.list_routing_profiles(
                          InstanceId=instance_id,
                          MaxResults=100
                      )
                      
                      # Find the Basic Routing Profile
                      routing_profile_id = None
                      routing_profile_arn = None
                      for profile in response['RoutingProfileSummaryList']:
                          if profile['Name'] == 'Basic Routing Profile':
                              routing_profile_id = profile['Id']
                              # Construct the ARN
                              routing_profile_arn = f"{instance_arn}/routing-profile/{routing_profile_id}"
                              break
                      
                      if not routing_profile_id:
                          # If Basic Routing Profile not found, use the first one
                          if response['RoutingProfileSummaryList']:
                              routing_profile_id = response['RoutingProfileSummaryList'][0]['Id']
                              routing_profile_arn = f"{instance_arn}/routing-profile/{routing_profile_id}"
                      
                      if routing_profile_id:
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                              'RoutingProfileId': routing_profile_id,
                              'RoutingProfileArn': routing_profile_arn
                          })
                      else:
                          cfnresponse.send(event, context, cfnresponse.FAILED, {
                              'Error': 'No routing profiles found'
                          })
                  except Exception as e:
                      logger.error(f"Error: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': str(e)
                      })
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
  # Lambda function to set up admin access
  SetupAdminAccessFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - ConnectSetupRole
      - ConnectInstance
    Properties:
      Handler: index.handler
      Role: !GetAtt ConnectSetupRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              logger.info(f"Event: {event}")
              
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      instance_id = event['ResourceProperties']['InstanceId']
                      instance_arn = event['ResourceProperties']['InstanceArn']
                      
                      # Initialize Connect client
                      connect = boto3.client('connect')
                      
                      # Find the Admin security profile
                      admin_security_profile_id = None
                      admin_security_profile_arn = None
                      
                      # List security profiles
                      response = connect.list_security_profiles(
                          InstanceId=instance_id,
                          MaxResults=100
                      )
                      
                      # Look for the Admin security profile
                      for profile in response['SecurityProfileSummaryList']:
                          if profile['Name'] == 'Admin':
                              admin_security_profile_id = profile['Id']
                              admin_security_profile_arn = f"{instance_arn}/security-profile/{admin_security_profile_id}"
                              logger.info(f"Found Admin security profile: {admin_security_profile_id}")
                              break
                      
                      if not admin_security_profile_id:
                          # If Admin profile not found, create one
                          logger.info("Admin security profile not found, creating one")
                          create_response = connect.create_security_profile(
                              InstanceId=instance_id,
                              SecurityProfileName="Admin",
                              Description="Admin with full access including Customer Profiles",
                              Permissions=["*"]  # Full access
                          )
                          admin_security_profile_id = create_response['SecurityProfileId']
                          admin_security_profile_arn = f"{instance_arn}/security-profile/{admin_security_profile_id}"
                          logger.info(f"Created Admin security profile: {admin_security_profile_id}")
                      
                      # Ensure the Admin profile has Customer Profiles permissions
                      try:
                          # Get current permissions
                          profile_details = connect.describe_security_profile(
                              InstanceId=instance_id,
                              SecurityProfileId=admin_security_profile_id
                          )
                          
                          current_permissions = profile_details.get('Permissions', [])
                          logger.info(f"Current permissions: {current_permissions}")
                          
                          # Add Customer Profiles permissions if not already present
                          required_permissions = [
                              "AdminAccess",
                              "CustomerProfiles.View", 
                              "CustomerProfiles.Edit", 
                              "CustomerProfiles.Delete",
                              "ContactSearch"
                          ]
                          
                          # Combine permissions, ensuring no duplicates
                          all_permissions = list(set(current_permissions + required_permissions))
                          
                          # Update the security profile with the combined permissions
                          connect.update_security_profile(
                              SecurityProfileId=admin_security_profile_id,
                              InstanceId=instance_id,
                              Permissions=all_permissions
                          )
                          logger.info(f"Updated Admin security profile with Customer Profiles permissions")
                          
                      except Exception as e:
                          logger.error(f"Error updating Admin security profile permissions: {str(e)}")
                      
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                          'AdminSecurityProfileId': admin_security_profile_id,
                          'AdminSecurityProfileArn': admin_security_profile_arn
                      })
                  except Exception as e:
                      logger.error(f"Error: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': str(e)
                      })
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
  # Custom resource to set up admin access
  SetupAdminAccess:
    Type: Custom::SetupAdminAccess
    DependsOn:
      - ConnectInstance
      - SetupAdminAccessFunction
    Properties:
      ServiceToken: !GetAtt SetupAdminAccessFunction.Arn
      InstanceId: !Ref ConnectInstance
      InstanceArn: !GetAtt ConnectInstance.Arn

  # Admin User with Full Access
  AdminUser:
    Type: AWS::Connect::User
    DependsOn:
      - ConnectInstance
      - SetupAdminAccess
    Properties:
      InstanceArn: !GetAtt ConnectInstance.Arn
      Username: !Ref AdminUsername
      Password: !Ref AdminPassword
      IdentityInfo:
        FirstName: "Admin"
        LastName: "User"
        Email: "admin@example.com"
      PhoneConfig:
        PhoneType: "SOFT_PHONE"
        AutoAccept: false
        AfterContactWorkTimeLimit: 300
        DeskPhoneNumber: ""
      SecurityProfileArns:
        - !GetAtt SetupAdminAccess.AdminSecurityProfileArn
      RoutingProfileArn: !GetAtt DefaultRoutingProfile.RoutingProfileArn
  # Lambda function to create a test customer profile
  CreateTestProfileFunction:
    Type: AWS::Lambda::Function
    DependsOn:
      - ConnectSetupRole
      - CustomerProfilesDomain
      - CustomerProfilesIntegration
    Properties:
      Handler: index.handler
      Role: !GetAtt ConnectSetupRole.Arn
      Runtime: python3.9
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import logging
          import time
          import uuid

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def handler(event, context):
              logger.info(f"Event: {event}")
              
              if event['RequestType'] in ['Create', 'Update']:
                  try:
                      domain_name = event['ResourceProperties']['DomainName']
                      
                      # Initialize Customer Profiles client
                      profile_client = boto3.client('customer-profiles')
                      
                      # Create a test customer profile
                      try:
                          # Generate a unique customer ID
                          customer_id = f"test-customer-{uuid.uuid4().hex[:8]}"
                          
                          # Create the profile
                          response = profile_client.create_profile(
                              DomainName=domain_name,
                              FirstName="Olivia",
                              LastName="Wilson",
                              PhoneNumber="+15555555555",
                              EmailAddress="OWilson@amazon.com",
                              AccountNumber=f"ACCT-{uuid.uuid4().hex[:8]}",
                              AdditionalInformation="Test customer profile created by CloudFormation"
                          )
                          
                          logger.info(f"Created test customer profile: {response}")
                          
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                              'ProfileId': response.get('ProfileId', 'unknown'),
                              'Message': 'Test customer profile created successfully'
                          })
                      except Exception as e:
                          logger.error(f"Error creating test customer profile: {str(e)}")
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                              'Message': f'Error creating test customer profile: {str(e)}'
                          })
                  except Exception as e:
                      logger.error(f"Error: {str(e)}")
                      cfnresponse.send(event, context, cfnresponse.FAILED, {
                          'Error': str(e)
                      })
              else:
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})

  # Custom resource to create a test customer profile
  CreateTestProfile:
    Type: Custom::CreateTestProfile
    DependsOn:
      - CustomerProfilesDomain
      - CustomerProfilesIntegration
      - CreateTestProfileFunction
    Properties:
      ServiceToken: !GetAtt CreateTestProfileFunction.Arn
      DomainName: !Sub 'amazon-connect-${AWS::StackName}'
  #===== SECTION 4: CONTACT FLOW DEPLOYMENT RESOURCES =====
  
  # IAM Role for Contact Flow Deployment
  ContactFlowDeploymentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ContactFlowDeploymentPolicy
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}'
                  - !Sub 'arn:aws:s3:::${SourceFilesBucket}/*'
              - Effect: Allow
                Action:
                  - connect:CreateContactFlow
                  - connect:UpdateContactFlowContent
                  - connect:UpdateContactFlowName
                  - connect:DescribeContactFlow
                  - connect:ListContactFlows
                Resource: !Sub '${ConnectInstance.Arn}/contact-flow/*'

  # Lambda Function for Contact Flow Deployment
  ContactFlowDeploymentFunction:
    Type: AWS::Lambda::Function
    Properties:
      Runtime: python3.9
      Handler: index.lambda_handler
      Role: !GetAtt ContactFlowDeploymentRole.Arn
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          import logging
          import cfnresponse
          from datetime import datetime

          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          s3_client = boto3.client('s3')
          connect_client = boto3.client('connect')

          def lambda_handler(event, context):
              try:
                  logger.info(f"Received event: {json.dumps(event)}")
                  
                  # If this is a Delete request, just send success and return
                  if event['RequestType'] == 'Delete':
                      logger.info("Delete request - sending success response")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  # For Create or Update requests, proceed with deployment
                  bucket_name = event['ResourceProperties']['BucketName']
                  instance_id = event['ResourceProperties']['InstanceId']
                  prefix = event['ResourceProperties']['Prefix']
                  
                  # List objects in the S3 bucket with the given prefix
                  logger.info(f"Listing objects in bucket {bucket_name} with prefix {prefix}")
                  deployed_flows = []
                  
                  try:
                      s3_response = s3_client.list_objects_v2(
                          Bucket=bucket_name,
                          Prefix=prefix
                      )
                      
                      # Extract available flow files
                      available_flows = []
                      if 'Contents' in s3_response:
                          for item in s3_response['Contents']:
                              key = item['Key']
                              if key.endswith('.json'):
                                  # Extract just the filename from the full path
                                  filename = key.split('/')[-1]
                                  available_flows.append({
                                      'filename': filename,
                                      'key': key
                                  })
                      
                      logger.info(f"Found {len(available_flows)} flow files: {[f['filename'] for f in available_flows]}")
                      
                      # Process each flow
                      for flow in available_flows:
                          deploy_contact_flow(bucket_name, instance_id, flow['key'], flow['filename'])
                          deployed_flows.append(flow['filename'])
                      
                      if not deployed_flows:
                          logger.warning(f"No contact flow files found in s3://{bucket_name}/{prefix}")
                      
                  except Exception as e:
                      logger.error(f"Error listing objects in S3: {str(e)}")
                      # Continue with hardcoded list as fallback
                      logger.info("Falling back to hardcoded flow list")
                  
                  # Send success response with deployed flows
                  response_data = {
                      'DeployedFlows': deployed_flows,
                      'Message': f"Successfully deployed {len(deployed_flows)} contact flows"
                  }
                  logger.info(f"Sending success response: {response_data}")
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, response_data)
                  
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  cfnresponse.send(
                      event, 
                      context, 
                      cfnresponse.FAILED, 
                      {'Error': str(e)},
                      reason=f"Error deploying contact flows: {str(e)}"
                  )

          def deploy_contact_flow(bucket_name, instance_id, key, flow_name):
              try:
                  # Get contact flow from S3
                  logger.info(f"Attempting to get contact flow {flow_name} from bucket {bucket_name}, key {key}")
                  
                  try:
                      response = s3_client.get_object(
                          Bucket=bucket_name,
                          Key=key
                      )
                      flow_content = response['Body'].read().decode('utf-8')
                      
                      # Extract name from filename and add timestamp
                      flow_name_without_ext = flow_name.replace('.json', '')
                      timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                      new_name = f"{flow_name_without_ext}_{timestamp}"
                      
                      # Create new contact flow with timestamped name
                      logger.info(f"Creating new contact flow: {new_name}")
                      
                      # Parse the flow content to modify the draft status
                      flow_data = json.loads(flow_content)
                      
                      # Ensure the flow has a Status field
                      if isinstance(flow_data, dict):
                          if 'Status' in flow_data:
                              flow_data['Status'] = 'SAVED'
                          elif 'status' in flow_data:
                              flow_data['status'] = 'SAVED'
                          elif 'Metadata' in flow_data and 'status' in flow_data['Metadata']:
                              flow_data['Metadata']['status'] = 'SAVED'
                      
                      connect_client.create_contact_flow(
                          InstanceId=instance_id,
                          Name=new_name,
                          Type='CONTACT_FLOW',  # Using default type
                          Content=json.dumps(flow_data),
                          Status='SAVED'  # Using Status instead of State
                      )
                      
                      logger.info(f"Successfully saved contact flow: {new_name}")
                      
                  except s3_client.exceptions.NoSuchKey:
                      logger.warning(f"Contact flow file not found: {key}")
                  except Exception as e:
                      logger.error(f"Error deploying contact flow {flow_name}: {str(e)}")
                      logger.error(f"Full error details: {e}")
                      raise
                      
              except Exception as e:
                  logger.error(f"Error deploying contact flow {flow_name}: {str(e)}")
                  logger.error(f"Full error details: {e}")
                  # Don't raise the exception here to allow other flows to be processed

      Timeout: 300
      MemorySize: 256

  # Custom Resource for Contact Flow Deployment
  ContactFlowDeploymentCustomResource:
    Type: Custom::ContactFlowDeployment
    DependsOn:
      - ConnectInstance
      - DownloadFilesCustomResource
    Properties:
      ServiceToken: !GetAtt ContactFlowDeploymentFunction.Arn
      BucketName: !Ref SourceFilesBucket
      InstanceId: !Ref ConnectInstance
      Prefix: "contactflows/"
  #===== SECTION 5: VIEWS DEPLOYMENT RESOURCES =====
  
  # IAM Role for Views Deployment
  ViewsDeploymentRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: ConnectAndS3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource: 
                  - !Sub "arn:aws:s3:::${SourceFilesBucket}"
                  - !Sub "arn:aws:s3:::${SourceFilesBucket}/*"
              - Effect: Allow
                Action:
                  - connect:CreateView
                  - connect:ListViews
                Resource: "*"
              - Effect: Allow
                Action:
                  - connect:DescribeInstance
                Resource: "*"

  # Lambda Function for Views Deployment
  ViewsDeploymentFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-ViewsDeploymentFunction"
      Runtime: python3.12
      Handler: index.lambda_handler
      Role: !GetAtt ViewsDeploymentRole.Arn
      Timeout: 900
      Environment:
        Variables:
          SOURCE_S3_BUCKET: !Ref SourceFilesBucket
          VIEWS_PREFIX: "views/"
          TARGET_INSTANCE_ID: !GetAtt ConnectInstance.Arn
      Code:
        ZipFile: |
          import boto3
          import json
          import os
          import re
          import traceback
          from botocore.exceptions import ClientError
          from datetime import datetime

          connect = boto3.client('connect')
          s3 = boto3.client('s3')

          def get_next_available_name(connect_client, instance_id, base_name):
              existing_names = set()
              try:
                  paginator = connect_client.get_paginator('list_views')
                  for page in paginator.paginate(InstanceId=instance_id, Type='CUSTOMER_MANAGED'):
                      for view in page['ViewsSummaryList']:
                          existing_names.add(view['Name'])
              except ClientError as e:
                  print(f"Connect API Error: {e}")
                  raise

              if base_name not in existing_names:
                  return base_name
              
              max_suffix = 0
              pattern = re.compile(rf"^{re.escape(base_name)}(?:-(\d+))?$")
              for name in existing_names:
                  match = pattern.match(name)
                  if match and match.group(1):
                      current_suffix = int(match.group(1))
                      max_suffix = max(max_suffix, current_suffix)
              
              return f"{base_name}-{max_suffix + 1}"

          def lambda_handler(event, context):
              try:
                  print(f"Initializing with bucket: {os.environ['SOURCE_S3_BUCKET']}")
                  source_bucket = os.environ['SOURCE_S3_BUCKET']
                  folder_prefix = os.environ.get('VIEWS_PREFIX', 'views/')
                  target_instance_id = os.environ['TARGET_INSTANCE_ID']
                  
                  if not target_instance_id.startswith('arn:aws:connect:'):
                      raise ValueError("Invalid Connect Instance ARN format")
                  
                  # Retrieve view configurations
                  paginator = s3.get_paginator('list_objects_v2')
                  pages = paginator.paginate(Bucket=source_bucket, Prefix=folder_prefix)
                  
                  view_configs = []
                  for page in pages:
                      view_configs.extend([
                          obj['Key'] for obj in page.get('Contents', [])
                          if obj['Key'].endswith('.json')
                      ])
                  print(f"Found {len(view_configs)} configurations to process")

                  if not view_configs:
                      return {
                          'statusCode': 404,
                          'body': f"No view configs found in s3://{source_bucket}/{folder_prefix}"
                      }

                  results = []
                  for config_key in view_configs:
                      try:
                          print(f"Processing {config_key}")
                          response = s3.get_object(Bucket=source_bucket, Key=config_key)
                          view_config = json.loads(response['Body'].read().decode('utf-8'))
                          
                          # Extract the name from the view config
                          if 'Name' in view_config:
                              base_name = view_config['Name']
                          else:
                              # Try to extract name from filename if not in config
                              base_name = config_key.split('/')[-1].replace('.json', '')
                          
                          description = view_config.get('Description', '').strip() or "No description provided"
                          
                          # Clean up the Content object to only include Template and Actions
                          if 'Content' in view_config:
                              content = view_config['Content']
                              # Remove any keys that are not Template or Actions
                              cleaned_content = {}
                              if 'Template' in content:
                                  cleaned_content['Template'] = content['Template']
                              if 'Actions' in content:
                                  cleaned_content['Actions'] = content['Actions']
                          else:
                              print(f"Warning: Missing Content in {config_key}, skipping")
                              continue
                          
                          # Generate unique view name
                          final_name = get_next_available_name(connect, target_instance_id, base_name)
                          print(f"Using view name: {final_name}")
                          
                          # Create view with idempotency token
                          client_token = f"{final_name}-{datetime.utcnow().isoformat()}"
                          response = connect.create_view(
                              InstanceId=target_instance_id,
                              Name=final_name,
                              Status='PUBLISHED',
                              Content=cleaned_content,
                              Description=description,
                              ClientToken=client_token
                          )
                          
                          results.append({
                              'view': final_name,
                              'original_name': base_name,
                              'status': 'success',
                              'arn': response['View']['Arn']
                          })

                      except Exception as e:
                          print(f"Error processing {config_key}: {str(e)}")
                          traceback.print_exc()
                          results.append({
                              'view': config_key,
                              'status': 'failed',
                              'error': str(e)
                          })

                  return {
                      'statusCode': 200,
                      'body': {
                          'processed': len(view_configs),
                          'results': results
                      }
                  }

              except ClientError as e:
                  print(f"AWS API Error: {e}")
                  return {
                      'statusCode': e.response['ResponseMetadata']['HTTPStatusCode'],
                      'body': f"{e.response['Error']['Code']}: {e.response['Error']['Message']}"
                  }
              except Exception as e:
                  print(f"Unexpected error: {e}")
                  traceback.print_exc()
                  return {
                      'statusCode': 500,
                      'body': f"Batch deployment failed: {str(e)}"
                  }
  # IAM Role for Views Invoker
  ViewsInvokerRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: InvokeLambdaPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action: lambda:InvokeFunction
                Resource: !GetAtt ViewsDeploymentFunction.Arn

  # Lambda Function for Views Invoker
  ViewsInvoker:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub "${AWS::StackName}-ViewsDeploymentFunction-Invoker"
      Handler: index.lambda_handler
      Runtime: python3.12
      Role: !GetAtt ViewsInvokerRole.Arn
      Timeout: 60
      Code:
        ZipFile: |
          import boto3
          import cfnresponse
          import json
          import logging
          
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)
          
          def lambda_handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")
              
              try:
                  # If this is a Delete request, just send success and return
                  if event['RequestType'] == 'Delete':
                      logger.info("Delete request - sending success response")
                      cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                      return
                  
                  # For Create or Update requests, invoke the target function
                  client = boto3.client('lambda')
                  target_function = event['ResourceProperties']['TargetFunction']
                  logger.info(f"Invoking target function: {target_function}")
                  
                  response = client.invoke(
                      FunctionName=target_function,
                      InvocationType='Event'
                  )
                  
                  logger.info(f"Lambda invoke response: {response}")
                  
                  # Send success response to CloudFormation
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'Message': f'Successfully invoked {target_function}'
                  })
                  
              except Exception as e:
                  logger.error(f"Error: {str(e)}")
                  cfnresponse.send(
                      event, 
                      context, 
                      cfnresponse.FAILED, 
                      {'Error': str(e)},
                      reason=f"Error invoking target function: {str(e)}"
                  )

  # Custom Resource for Views Deployment
  ExecuteViewsDeployment:
    Type: Custom::InvokeLambda
    DependsOn: 
      - ViewsDeploymentFunction
      - ViewsInvoker
      - ConnectInstance
      - DownloadFilesCustomResource
    Properties:
      ServiceToken: !GetAtt ViewsInvoker.Arn
      TargetFunction: !Ref ViewsDeploymentFunction

Outputs:
  # Website Outputs
  WebsiteURL:
    Description: CloudFront distribution URL
    Value: !GetAtt CloudFrontDistribution.DomainName
    
  S3BucketName:
    Description: Name of the S3 bucket created for the website
    Value: !Ref S3Bucket
    
  FAQBucketName:
    Description: Name of the S3 bucket created for FAQ documents
    Value: !Ref FAQBucket
  
  # Connect Outputs
  ConnectInstanceId:
    Description: Amazon Connect Instance ID
    Value: !Ref ConnectInstance
  
  ConnectInstanceArn:
    Description: Amazon Connect Instance ARN
    Value: !GetAtt ConnectInstance.Arn
  
  CustomerProfilesDomainName:
    Description: Customer Profiles Domain Name
    Value: !Sub 'amazon-connect-${AWS::StackName}'
    
  CustomerProfilesIntegrationId:
    Description: The ID of the Customer Profiles Integration with Connect
    Value: !Ref CustomerProfilesIntegration
    
  AdminUsername:
    Description: Admin username for Amazon Connect
    Value: !Ref AdminUsername
    
  AdminSecurityProfileId:
    Description: Security Profile ID for admin with full access
    Value: !GetAtt SetupAdminAccess.AdminSecurityProfileId
    
  TestProfileCreated:
    Description: Status of test customer profile creation
    Value: !GetAtt CreateTestProfile.Message
    
  ContactFlowDeploymentFunctionArn:
    Description: ARN of the Contact Flow deployment Lambda function
    Value: !GetAtt ContactFlowDeploymentFunction.Arn
  
  ViewsDeploymentFunctionArn:
    Description: ARN of the Views deployment Lambda function
    Value: !GetAtt ViewsDeploymentFunction.Arn
